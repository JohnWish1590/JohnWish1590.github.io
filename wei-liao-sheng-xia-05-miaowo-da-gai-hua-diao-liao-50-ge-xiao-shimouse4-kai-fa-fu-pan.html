<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>为了省下 0.5 秒，我大概花掉了 50 个小时：Mouse4 开发复盘 - JohnWish就是约翰祈祷</title><meta name="description" content="JohnWish1590 一月 21, 2026 如果用 ROI（投资回报率）来计算，Mouse4 绝对是一个失败的项目。 为了省去把鼠标移到左上角点“返回”的那 0.5 秒，或者为了省去登录微信才能截图的麻烦，我前后迭代了 55 个版本，重写了三次渲染核心，甚至为了修一个 Bug 去翻了 Windows 的底层 API 文档。 但这就是程序员（或者说极客）的宿命：我们无法忍受工具的“钝感”。 Mouse4 的诞生，不是为了做一个通用的软件，而是为了打造一个完全契合我个人生理习惯的“数字义肢”。 最早的 Mouse4 其实不叫 Mouse4，它只是一段几 KB 的 Python 脚本。 作为一个需要高频浏览财报和文件的基金经理/老师，Windows 资源管理器的交互逻辑让我抓狂：为什么“进入文件夹”是双击，而“返回上一级”却要大幅度移动鼠标去点那个该死的箭头？ 我的需求很原始： 我希望我的鼠标在哪里，哪里就是控制台。 于是，我利用 UIAutomation 做了一个简单的钩子：当且仅当鼠标停留在文件夹的空白处双击时，模拟按下 Backspace。 这个功能上线后，我几乎忘记了它的存在。这才是工具的最高境界——隐形。它变成了我肌肉记忆的一部分，以至于我在别人的电脑上操作时，总会下意识地双击空白处，然后看着毫无反应的屏幕发愣。 如果说“双击返回”是顺手，那“截图”功能的开发就是一场与 Windows 缩放机制的恶战。 作为一个多屏重度用户（左竖屏看盘，中横屏工作，右屏摸鱼），我的桌面环境简直是开发者的噩梦： 显示器 1：4K 分辨率，200%&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://JohnWish1590.github.io/wei-liao-sheng-xia-05-miaowo-da-gai-hua-diao-liao-50-ge-xiao-shimouse4-kai-fa-fu-pan.html"><link rel="alternate" type="application/atom+xml" href="https://JohnWish1590.github.io/feed.xml" title="JohnWish就是约翰祈祷 - RSS"><link rel="alternate" type="application/json" href="https://JohnWish1590.github.io/feed.json" title="JohnWish就是约翰祈祷 - JSON"><meta property="og:title" content="为了省下 0.5 秒，我大概花掉了 50 个小时：Mouse4 开发复盘"><meta property="og:site_name" content="JohnWish就是约翰祈祷"><meta property="og:description" content="JohnWish1590 一月 21, 2026 如果用 ROI（投资回报率）来计算，Mouse4 绝对是一个失败的项目。 为了省去把鼠标移到左上角点“返回”的那 0.5 秒，或者为了省去登录微信才能截图的麻烦，我前后迭代了 55 个版本，重写了三次渲染核心，甚至为了修一个 Bug 去翻了 Windows 的底层 API 文档。 但这就是程序员（或者说极客）的宿命：我们无法忍受工具的“钝感”。 Mouse4 的诞生，不是为了做一个通用的软件，而是为了打造一个完全契合我个人生理习惯的“数字义肢”。 最早的 Mouse4 其实不叫 Mouse4，它只是一段几 KB 的 Python 脚本。 作为一个需要高频浏览财报和文件的基金经理/老师，Windows 资源管理器的交互逻辑让我抓狂：为什么“进入文件夹”是双击，而“返回上一级”却要大幅度移动鼠标去点那个该死的箭头？ 我的需求很原始： 我希望我的鼠标在哪里，哪里就是控制台。 于是，我利用 UIAutomation 做了一个简单的钩子：当且仅当鼠标停留在文件夹的空白处双击时，模拟按下 Backspace。 这个功能上线后，我几乎忘记了它的存在。这才是工具的最高境界——隐形。它变成了我肌肉记忆的一部分，以至于我在别人的电脑上操作时，总会下意识地双击空白处，然后看着毫无反应的屏幕发愣。 如果说“双击返回”是顺手，那“截图”功能的开发就是一场与 Windows 缩放机制的恶战。 作为一个多屏重度用户（左竖屏看盘，中横屏工作，右屏摸鱼），我的桌面环境简直是开发者的噩梦： 显示器 1：4K 分辨率，200%&hellip;"><meta property="og:url" content="https://JohnWish1590.github.io/wei-liao-sheng-xia-05-miaowo-da-gai-hua-diao-liao-50-ge-xiao-shimouse4-kai-fa-fu-pan.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://JohnWish1590.github.io/assets/css/style.css?v=b09e72b2ca1a38c969d44da51bb22509"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://JohnWish1590.github.io/wei-liao-sheng-xia-05-miaowo-da-gai-hua-diao-liao-50-ge-xiao-shimouse4-kai-fa-fu-pan.html"},"headline":"为了省下 0.5 秒，我大概花掉了 50 个小时：Mouse4 开发复盘","datePublished":"2026-01-21T19:36+08:00","dateModified":"2026-01-21T19:36+08:00","description":"JohnWish1590 一月 21, 2026 如果用 ROI（投资回报率）来计算，Mouse4 绝对是一个失败的项目。 为了省去把鼠标移到左上角点“返回”的那 0.5 秒，或者为了省去登录微信才能截图的麻烦，我前后迭代了 55 个版本，重写了三次渲染核心，甚至为了修一个 Bug 去翻了 Windows 的底层 API 文档。 但这就是程序员（或者说极客）的宿命：我们无法忍受工具的“钝感”。 Mouse4 的诞生，不是为了做一个通用的软件，而是为了打造一个完全契合我个人生理习惯的“数字义肢”。 最早的 Mouse4 其实不叫 Mouse4，它只是一段几 KB 的 Python 脚本。 作为一个需要高频浏览财报和文件的基金经理/老师，Windows 资源管理器的交互逻辑让我抓狂：为什么“进入文件夹”是双击，而“返回上一级”却要大幅度移动鼠标去点那个该死的箭头？ 我的需求很原始： 我希望我的鼠标在哪里，哪里就是控制台。 于是，我利用 UIAutomation 做了一个简单的钩子：当且仅当鼠标停留在文件夹的空白处双击时，模拟按下 Backspace。 这个功能上线后，我几乎忘记了它的存在。这才是工具的最高境界——隐形。它变成了我肌肉记忆的一部分，以至于我在别人的电脑上操作时，总会下意识地双击空白处，然后看着毫无反应的屏幕发愣。 如果说“双击返回”是顺手，那“截图”功能的开发就是一场与 Windows 缩放机制的恶战。 作为一个多屏重度用户（左竖屏看盘，中横屏工作，右屏摸鱼），我的桌面环境简直是开发者的噩梦： 显示器 1：4K 分辨率，200%&hellip;","author":{"@type":"Person","name":"JohnWish1590","url":"https://JohnWish1590.github.io/authors/johnwish1590/"},"publisher":{"@type":"Organization","name":"JohnWish1590"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://JohnWish1590.github.io/">JohnWish就是约翰祈祷</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>为了省下 0.5 秒，我大概花掉了 50 个小时：Mouse4 开发复盘</h1><div class="feed__meta content__meta"><a href="https://JohnWish1590.github.io/authors/johnwish1590/" class="feed__author">JohnWish1590</a> <time datetime="2026-01-21T19:36" class="feed__date">一月 21, 2026</time></div></div></header></div><div class="entry-wrapper content__entry"><p><strong data-path-to-node="5" data-index-in-node="0">JohnWish1590</strong> 一月 21, 2026</p><h3 data-path-to-node="6">0. 这种“过度工程”值得吗？</h3><p data-path-to-node="7">如果用 ROI（投资回报率）来计算，Mouse4 绝对是一个失败的项目。</p><p data-path-to-node="8">为了省去把鼠标移到左上角点“返回”的那 0.5 秒，或者为了省去登录微信才能截图的麻烦，我前后迭代了 55 个版本，重写了三次渲染核心，甚至为了修一个 Bug 去翻了 Windows 的底层 API 文档。</p><p data-path-to-node="9">但这就是程序员（或者说极客）的宿命：<strong data-path-to-node="9" data-index-in-node="18">我们无法忍受工具的“钝感”。</strong></p><p data-path-to-node="10">Mouse4 的诞生，不是为了做一个通用的软件，而是为了打造一个<strong data-path-to-node="10" data-index-in-node="32">完全契合我个人生理习惯的“数字义肢”</strong>。</p><h3 data-path-to-node="11">1. 第一层：肌肉记忆的延伸</h3><p data-path-to-node="12">最早的 Mouse4 其实不叫 Mouse4，它只是一段几 KB 的 Python 脚本。</p><p data-path-to-node="13">作为一个需要高频浏览财报和文件的基金经理/老师，Windows 资源管理器的交互逻辑让我抓狂：为什么“进入文件夹”是双击，而“返回上一级”却要大幅度移动鼠标去点那个该死的箭头？</p><p data-path-to-node="14"><strong data-path-to-node="14" data-index-in-node="0">我的需求很原始：</strong> 我希望我的鼠标在哪里，哪里就是控制台。</p><p data-path-to-node="15">于是，我利用 <code data-path-to-node="15" data-index-in-node="7">UIAutomation</code> 做了一个简单的钩子：<strong data-path-to-node="15" data-index-in-node="30">当且仅当</strong>鼠标停留在文件夹的空白处双击时，模拟按下 <code data-path-to-node="15" data-index-in-node="55">Backspace</code>。</p><p data-path-to-node="16">这个功能上线后，我几乎忘记了它的存在。这才是工具的最高境界——<strong data-path-to-node="16" data-index-in-node="31">隐形</strong>。它变成了我肌肉记忆的一部分，以至于我在别人的电脑上操作时，总会下意识地双击空白处，然后看着毫无反应的屏幕发愣。</p><h3 data-path-to-node="17">2. 第二层：与“物理像素”的战争</h3><p data-path-to-node="18">如果说“双击返回”是顺手，那“截图”功能的开发就是一场<strong data-path-to-node="18" data-index-in-node="27">与 Windows 缩放机制的恶战</strong>。</p><p data-path-to-node="19">作为一个多屏重度用户（左竖屏看盘，中横屏工作，右屏摸鱼），我的桌面环境简直是开发者的噩梦：</p><ul data-path-to-node="20"><li><p data-path-to-node="20,0,0">显示器 1：4K 分辨率，200% 缩放。</p></li><li><p data-path-to-node="20,1,0">显示器 2：4K 分辨率，150% 缩放。</p></li><li><p data-path-to-node="20,2,0">显示器 3：1080P 分辨率，100% 缩放。</p></li></ul><p data-path-to-node="21">当我试图把截图功能加上去时，Python 的 GUI 库（PyQt）彻底晕了。 在 4K 屏上截图，画面要么被暴力拉伸成马赛克，要么截取的区域和鼠标选中的区域完全错位。最夸张的一次，我在中间屏幕画了一个圆，结果鼠标松开时，那个圆出现在了右边的屏幕上。</p><p data-path-to-node="22"><strong data-path-to-node="22" data-index-in-node="0">这背后的技术鸿沟在于：</strong> 操作系统为了照顾旧软件，会把 4K 屏“谎报”成 1080P（逻辑像素）。而截图软件需要的是“真·4K”（物理像素）。</p><p data-path-to-node="23"><strong data-path-to-node="23" data-index-in-node="0">这就导致了“坐标系打架”：</strong></p><ul data-path-to-node="24"><li><p data-path-to-node="24,0,0">鼠标说：“我在坐标 (500, 500)。”</p></li><li><p data-path-to-node="24,1,0">屏幕说：“好的，但在我这里，那是物理像素 (1000, 1000)。”</p></li><li><p data-path-to-node="24,2,0">截图引擎说：“啊？那我到底该切哪块图？”</p></li></ul><p data-path-to-node="25">在 V48 到 V54 的几十次崩溃中，我最终放弃了依赖框架的自动缩放。我写了一套<strong data-path-to-node="25" data-index-in-node="41">手动映射算法</strong>，强行接管了所有坐标计算。现在的 Mouse4，是在像素级别上“手动”把逻辑坐标对齐回了物理坐标。</p><p data-path-to-node="26">这种<strong data-path-to-node="26" data-index-in-node="2">严丝合缝</strong>的快感，只有在 200% 缩放的屏幕上拖出一个像素都不差的选区时，才能体会得到。</p><h3 data-path-to-node="27">3. 第三层：来自 Excel 的“幽灵”</h3><p data-path-to-node="28">就在我以为大功告成时，一个足以逼疯开发者的 Bug 出现了。</p><p data-path-to-node="29">有一天，我正在 Excel 里输入数据 <code data-path-to-node="29" data-index-in-node="20">712</code>，屏幕突然一黑，截图界面弹了出来。 我的快捷键是 <code data-path-to-node="29" data-index-in-node="48">Ctrl+1</code>。但我发誓，我当时绝对没有按 <code data-path-to-node="29" data-index-in-node="69">Ctrl</code>。</p><p data-path-to-node="30"><strong data-path-to-node="30" data-index-in-node="0">这简直是玄学。</strong> 难道我的键盘漏电了？</p><p data-path-to-node="31">经过排查，罪魁祸首竟然是**“手速太快”<strong data-path-to-node="31" data-index-in-node="20">。 我在输入数字前，习惯性地用了 <code data-path-to-node="31" data-index-in-node="37">Ctrl+C</code> 复制数据。当我快速切换窗口并敲击键盘时，Windows 的消息队列有时候会“跟不上”，导致 Python 的监听库</strong>没听到** <code data-path-to-node="31" data-index-in-node="107">Ctrl</code> 键弹起的那一声信号。</p><p data-path-to-node="32">于是，在程序的认知里，<code data-path-to-node="32" data-index-in-node="11">Ctrl</code> 键一直是被按住的（幽灵状态）。此时我只要按个 <code data-path-to-node="32" data-index-in-node="39">1</code>，程序就判定：<code data-path-to-node="32" data-index-in-node="47">Ctrl + 1</code> 触发！</p><p data-path-to-node="33"><strong data-path-to-node="33" data-index-in-node="0">为了杀掉这个幽灵，我被迫降维打击：</strong> 在 V55 版本中，我引入了 C++ 时代的古老兵器 —— <code data-path-to-node="33" data-index-in-node="48">GetAsyncKeyState</code>。 现在，每当你按下快捷键，Mouse4 不会轻易相信，而是会直接<strong data-path-to-node="33" data-index-in-node="97">质问操作系统底层</strong>：“现在的物理键盘上，Ctrl 键到底有没有通电？”</p><p data-path-to-node="34">只有物理层面的确认，才能打败逻辑层面的延迟。从此，那个幽灵消失了。</p><h3 data-path-to-node="35">4. 尾声：工具的温度</h3><p data-path-to-node="36">回顾这几十个小时的折腾，原本只是想把两个小功能缝合在一起，最后却变成了一场涉及<strong data-path-to-node="36" data-index-in-node="39">底层钩子、高分屏渲染算法、多线程并发</strong>的技术练兵。</p><p data-path-to-node="37">现在的 Mouse4，界面依然简陋，没有任何多余的动画。 但当我每天几百次地双击空白处返回，或者在 4K 屏上极其顺滑地截下一张图时，这种<strong data-path-to-node="37" data-index-in-node="69">完全受控、绝对精准</strong>的感觉，让我觉得这一切“无用功”都是值得的。</p><p data-path-to-node="38">这可能就是我们折腾工具的意义： <strong data-path-to-node="38" data-index-in-node="16">在这个充满不确定性的世界上，至少手中的鼠标和代码，永远忠诚于你。</strong></p><hr data-path-to-node="39"><p data-path-to-node="40"><strong data-path-to-node="40" data-index-in-node="0">This article was updated on 一月 21, 2026</strong></p><p data-path-to-node="41"><strong data-path-to-node="41" data-index-in-node="0">Share It</strong> <strong data-path-to-node="41" data-index-in-node="9">JohnWish1590</strong> <strong data-path-to-node="41" data-index-in-node="22">Powered by Publii</strong></p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on 一月 21, 2026</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://JohnWish1590.github.io/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://JohnWish1590.github.io/authors/johnwish1590/" rel="author">JohnWish1590</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://JohnWish1590.github.io/wo-ru-he-yong-ai-zai-48-xiao-shi-nei-ba-python-jiao-ben-bian-chengge-ren-peng-bo-zhong-duan.html" class="content__nav-link" rel="prev"><div><span>Previous</span> 我如何用 AI 在 48 小时内把 Python 脚本变成“个人彭博终端”</div></a></div></div></div></nav></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://JohnWish1590.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://JohnWish1590.github.io/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script></body></html>